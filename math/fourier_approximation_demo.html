<!--
https://chatgpt.com/share/68abbb2e-6210-8010-ae97-d516d898d07b

All the prompts and discussions to generate this file are in the chat.

-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fourier Series — Function Approximation</title>
  <style>
    :root {
      --bg: #0f1221;
      --panel: #151936;
      --ink: #e8ecff;
      --muted: #9aa4c7;
      --accent: #7aa2ff;
      --accent2: #79f2c3;
      --grid: #2a2f55;
      --warn: #ffb86c;
      --error: #ff6b6b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--ink);
      background: radial-gradient(1200px 600px at 10% -10%, #1a1f43 0%, var(--bg) 60%);
    }
    .wrap { max-width: 1100px; margin: 32px auto; padding: 0 16px; }
    h1 { font-size: clamp(20px, 2vw + 12px, 32px); margin: 0 0 16px 0; }

    .controls {
      background: linear-gradient(180deg, #181d3d, var(--panel));
      border: 1px solid #2a2f59;
      border-radius: 16px;
      padding: 16px;
      display: grid; gap: 14px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: center; }
    .row2 { display: grid; grid-template-columns: 1fr; gap: 10px; }
    label { color: var(--muted); }

    input[type="text"] {
      width: 100%;
      padding: 10px 12px; border-radius: 12px; border: 1px solid #2a2f59; background: #0d1230; color: var(--ink);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    .templates { display: flex; flex-wrap: wrap; gap: 8px; }
    .btn {
      appearance: none; border: 1px solid #2a2f59; background: #10163a; color: var(--ink);
      padding: 8px 12px; border-radius: 12px; cursor: pointer; font-size: 14px;
    }
    .btn:hover { border-color: #3a4a7a; }

    .sliderRow { display: grid; grid-template-columns: 1fr max-content; gap: 10px; align-items: center; }
    input[type="range"] { width: 100%; }
    .badge { font-variant-numeric: tabular-nums; color: var(--accent2); background: #0e1a2c; border: 1px solid #1e3352; padding: 6px 10px; border-radius: 10px; }

    .legend { display: flex; gap: 18px; align-items: center; flex-wrap: wrap; color: var(--muted); }
    .key { display: inline-flex; align-items: center; gap: 8px; }
    .swatch { width: 18px; height: 2px; background: var(--accent); display: inline-block; }
    .swatch2 { width: 18px; height: 2px; background: var(--accent2); display: inline-block; }

    .panel { margin-top: 16px; background: var(--panel); border: 1px solid #202653; border-radius: 18px; overflow: hidden; box-shadow: 0 12px 30px rgba(0,0,0,0.25); }
    canvas { display: block; width: 100%; height: 520px; background: transparent; }

    .note { color: var(--muted); margin-top: 12px; font-size: 14px; }
    .error { color: var(--error); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Fourier Series Approximation of Functions</h1>

    <div class="controls">
      <div class="row2">
        <label for="funcInput">Function <code>f(x)</code> on <code>[0, 2π]</code> (periodic). Use math functions like <code>sin(x)</code>, <code>cos(x)</code>, operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>, and conditionals <code>x < PI ? 1 : -1</code>:</label>
        <input id="funcInput" type="text" value="x < PI ? 1 : -1" />
        <div class="templates">
          <button class="btn" data-template="square">Square wave</button>
          <button class="btn" data-template="saw">Sawtooth</button>
          <button class="btn" data-template="tri">Triangle</button>
          <button class="btn" data-template="sine">Sine</button>
          <button class="btn" data-template="abssin">|sin x|</button>
          <button class="btn" data-template="cosmix">Cos mix</button>
        </div>
      </div>

      <div class="sliderRow">
        <div>
          <label for="nRange">Number of harmonics (N): <span id="nLabel" class="badge">N = 15</span></label>
          <input id="nRange" type="range" min="1" max="99" step="1" value="15" />
        </div>
        <button id="recomputeBtn" class="btn" title="Recompute coefficients up to slider's max for snappy N changes">Recompute</button>
      </div>

      <div class="legend">
        <span class="key"><span class="swatch"></span> Fourier approximation</span>
        <span class="key"><span class="swatch2"></span> Original function</span>
        <span class="key">Domain: <code>[0, 2π]</code></span>
      </div>
    </div>

    <div class="panel">
      <canvas id="plot"></canvas>
    </div>

    <div class="note" id="status"></div>
    <div class="note">Tip: The coefficients are computed assuming period <code>2π</code>. Your input is interpreted modulo <code>2π</code>.</div>
  </div>

  <script>
    // ---------- Utilities ----------
    const TAU = Math.PI * 2;

    function wrap2pi(x) {
      let y = x % TAU;
      if (y < 0) y += TAU;
      return y;
    }

    // Safe mathematical expression parser without eval
    function makeUserFunction(expr) {
      // Create a safe math evaluator
      const mathEvaluator = createMathEvaluator();
      
      return (x) => {
        const xn = wrap2pi(x);
        try {
          const v = mathEvaluator.evaluate(expr, { x: xn });
          if (!Number.isFinite(v)) throw new Error('f(x) returned non-finite value');
          return v;
        } catch (e) {
          throw new Error(`Evaluation error: ${e.message}`);
        }
      };
    }

    // Create a safe mathematical expression evaluator
    function createMathEvaluator() {
      // Tokenizer
      function tokenize(expr) {
        const tokens = [];
        let i = 0;
        const str = expr.replace(/\s+/g, '');
        
        while (i < str.length) {
          let char = str[i];
          
          // Numbers (including decimals)
          if (/\d/.test(char) || char === '.') {
            let num = '';
            while (i < str.length && (/[\d\.]/.test(str[i]))) {
              num += str[i++];
            }
            tokens.push({ type: 'NUMBER', value: parseFloat(num) });
            continue;
          }
          
          // Variables and functions
          if (/[a-zA-Z]/.test(char)) {
            let name = '';
            while (i < str.length && /[a-zA-Z]/.test(str[i])) {
              name += str[i++];
            }
            tokens.push({ type: 'IDENTIFIER', value: name });
            continue;
          }
          
          // Operators and punctuation
          const operators = {
            '+': 'PLUS', '-': 'MINUS', '*': 'MULTIPLY', '/': 'DIVIDE',
            '^': 'POWER', '(': 'LPAREN', ')': 'RPAREN', '?': 'QUESTION',
            ':': 'COLON', '<': 'LT', '>': 'GT', '=': 'EQ'
          };
          
          if (operators[char]) {
            tokens.push({ type: operators[char], value: char });
            i++;
            continue;
          }
          
          throw new Error(`Unexpected character: ${char}`);
        }
        
        return tokens;
      }
      
      // Parser with precedence
      function parse(tokens) {
        let pos = 0;
        
        function peek() { return tokens[pos]; }
        function consume(expectedType) {
          const token = tokens[pos++];
          if (expectedType && token?.type !== expectedType) {
            throw new Error(`Expected ${expectedType}, got ${token?.type || 'EOF'}`);
          }
          return token;
        }
        
        function parseExpression() { return parseTernary(); }
        
        function parseTernary() {
          let expr = parseComparison();
          if (peek()?.type === 'QUESTION') {
            consume('QUESTION');
            const trueExpr = parseComparison();
            consume('COLON');
            const falseExpr = parseComparison();
            expr = { type: 'TERNARY', condition: expr, trueExpr, falseExpr };
          }
          return expr;
        }
        
        function parseComparison() {
          let expr = parseAddSub();
          while (peek()?.type === 'LT' || peek()?.type === 'GT' || peek()?.type === 'EQ') {
            const op = consume().value;
            const right = parseAddSub();
            expr = { type: 'BINARY', op, left: expr, right };
          }
          return expr;
        }
        
        function parseAddSub() {
          let expr = parseMulDiv();
          while (peek()?.type === 'PLUS' || peek()?.type === 'MINUS') {
            const op = consume().value;
            const right = parseMulDiv();
            expr = { type: 'BINARY', op, left: expr, right };
          }
          return expr;
        }
        
        function parseMulDiv() {
          let expr = parsePower();
          while (peek()?.type === 'MULTIPLY' || peek()?.type === 'DIVIDE') {
            const op = consume().value;
            const right = parsePower();
            expr = { type: 'BINARY', op, left: expr, right };
          }
          return expr;
        }
        
        function parsePower() {
          let expr = parseUnary();
          if (peek()?.type === 'POWER') {
            consume('POWER');
            const right = parsePower(); // right associative
            expr = { type: 'BINARY', op: '^', left: expr, right };
          }
          return expr;
        }
        
        function parseUnary() {
          if (peek()?.type === 'MINUS') {
            consume('MINUS');
            return { type: 'UNARY', op: '-', expr: parseUnary() };
          }
          return parsePrimary();
        }
        
        function parsePrimary() {
          const token = peek();
          
          if (token?.type === 'NUMBER') {
            consume('NUMBER');
            return { type: 'NUMBER', value: token.value };
          }
          
          if (token?.type === 'IDENTIFIER') {
            const name = consume('IDENTIFIER').value;
            if (peek()?.type === 'LPAREN') {
              consume('LPAREN');
              const args = [];
              if (peek()?.type !== 'RPAREN') {
                args.push(parseExpression());
                while (peek()?.type === 'PLUS' || peek()?.type === 'MINUS') { // Handle implicit multiplication
                  break;
                }
              }
              consume('RPAREN');
              return { type: 'FUNCTION', name, args };
            }
            return { type: 'VARIABLE', name };
          }
          
          if (token?.type === 'LPAREN') {
            consume('LPAREN');
            const expr = parseExpression();
            consume('RPAREN');
            return expr;
          }
          
          throw new Error(`Unexpected token: ${token?.type}`);
        }
        
        return parseExpression();
      }
      
      // Math functions registry
      const mathFunctions = {
        sin: Math.sin, cos: Math.cos, tan: Math.tan,
        asin: Math.asin, acos: Math.acos, atan: Math.atan,
        sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh,
        log: Math.log, ln: Math.log, log10: Math.log10,
        exp: Math.exp, sqrt: Math.sqrt, abs: Math.abs,
        floor: Math.floor, ceil: Math.ceil, round: Math.round,
        pow: Math.pow, min: Math.min, max: Math.max
      };
      
      const mathConstants = {
        PI: Math.PI, E: Math.E
      };
      
      // Evaluator
      function evaluateAST(ast, variables = {}) {
        switch (ast.type) {
          case 'NUMBER':
            return ast.value;
            
          case 'VARIABLE':
            if (ast.name in variables) return variables[ast.name];
            if (ast.name in mathConstants) return mathConstants[ast.name];
            throw new Error(`Unknown variable: ${ast.name}`);
            
          case 'FUNCTION':
            const func = mathFunctions[ast.name];
            if (!func) throw new Error(`Unknown function: ${ast.name}`);
            const args = ast.args.map(arg => evaluateAST(arg, variables));
            return func(...args);
            
          case 'BINARY':
            const left = evaluateAST(ast.left, variables);
            const right = evaluateAST(ast.right, variables);
            switch (ast.op) {
              case '+': return left + right;
              case '-': return left - right;
              case '*': return left * right;
              case '/': return left / right;
              case '^': return Math.pow(left, right);
              case '<': return left < right ? 1 : 0;
              case '>': return left > right ? 1 : 0;
              case '=': return Math.abs(left - right) < 1e-10 ? 1 : 0;
              default: throw new Error(`Unknown operator: ${ast.op}`);
            }
            
          case 'UNARY':
            const expr = evaluateAST(ast.expr, variables);
            switch (ast.op) {
              case '-': return -expr;
              default: throw new Error(`Unknown unary operator: ${ast.op}`);
            }
            
          case 'TERNARY':
            const condition = evaluateAST(ast.condition, variables);
            return condition ? evaluateAST(ast.trueExpr, variables) : evaluateAST(ast.falseExpr, variables);
            
          default:
            throw new Error(`Unknown AST node type: ${ast.type}`);
        }
      }
      
      return {
        evaluate(expr, variables = {}) {
          const tokens = tokenize(expr);
          const ast = parse(tokens);
          return evaluateAST(ast, variables);
        }
      };
    }

    function linspace(a, b, n) {
      const arr = new Float64Array(n);
      const step = (b - a) / (n - 1);
      for (let i = 0; i < n; i++) arr[i] = a + i * step;
      return arr;
    }

    // Compute Fourier coefficients up to Nmax for 2π-periodic f(x)
    function computeCoeffs(f, Nmax) {
      const a = new Float64Array(Nmax + 1);
      const b = new Float64Array(Nmax + 1);
      const M = 2048; // integration resolution
      const dx = TAU / M;

      const fx = new Float64Array(M + 1);
      const w = new Float64Array(M + 1);
      for (let i = 0; i <= M; i++) {
        const x = i * dx;
        const val = f(x);
        if (!Number.isFinite(val)) throw new Error('Non-finite value encountered in f(x)');
        fx[i] = val;
        w[i] = (i === 0 || i === M) ? 0.5 : 1.0; // trapezoid weights
      }

      // a0
      let sum0 = 0;
      for (let i = 0; i <= M; i++) sum0 += fx[i] * w[i];
      a[0] = (1/Math.PI) * (sum0 * dx);

      for (let n = 1; n <= Nmax; n++) {
        let sumA = 0, sumB = 0;
        for (let i = 0; i <= M; i++) {
          const x = i * dx;
          const ww = w[i];
          const fxi = fx[i];
          sumA += fxi * Math.cos(n * x) * ww;
          sumB += fxi * Math.sin(n * x) * ww;
        }
        a[n] = (1/Math.PI) * (sumA * dx);
        b[n] = (1/Math.PI) * (sumB * dx);
      }

      return { a, b };
    }

    function fourierAt(x, coeffs, N) {
      let y = coeffs.a[0] / 2;
      for (let n = 1; n <= N; n++) {
        y += coeffs.a[n] * Math.cos(n * x) + coeffs.b[n] * Math.sin(n * x);
      }
      return y;
    }

    // ---------- Plot ----------
    function resizeCanvasToDisplaySize(canvas, heightPx = 520) {
      const ratio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const rectWidth = canvas.clientWidth;
      const rectHeight = heightPx;
      if (canvas.width !== rectWidth * ratio || canvas.height !== rectHeight * ratio) {
        canvas.width = rectWidth * ratio;
        canvas.height = rectHeight * ratio;
      }
      const ctx = canvas.getContext('2d');
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      return ctx;
    }

    function makePlot(canvas) {
      const ctx = resizeCanvasToDisplaySize(canvas);
      const W = canvas.clientWidth, H = canvas.clientHeight;
      const pad = 28;
      const plotW = W - pad*2;
      const plotH = H - pad*2;
      const xMin = 0, xMax = TAU;
      const xToPx = x => pad + (x - xMin) / (xMax - xMin) * plotW;
      let yMin = -1.4, yMax = 1.4;
      const yToPx = y => pad + (1 - (y - yMin) / (yMax - yMin)) * plotH;

      function drawAxes() {
        ctx.clearRect(0, 0, W, H);
        ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
        ctx.lineWidth = 1;
        ctx.beginPath();
        const gridY = 6;
        for (let i = 0; i <= gridY; i++) {
          const gy = yMin + (yMax - yMin) * (i / gridY);
          const py = yToPx(gy);
          ctx.moveTo(pad, py); ctx.lineTo(W - pad, py);
        }
        const ticks = 8;
        for (let i = 0; i <= ticks; i++) {
          const x = xMin + (xMax - xMin) * (i / ticks);
          const px = xToPx(x);
          ctx.moveTo(px, pad); ctx.lineTo(px, H - pad);
        }
        ctx.stroke();

        ctx.strokeStyle = '#3a4182';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(pad, yToPx(0)); ctx.lineTo(W - pad, yToPx(0));
        ctx.moveTo(xToPx(0), pad); ctx.lineTo(xToPx(0), H - pad);
        ctx.stroke();

        ctx.fillStyle = getComputedStyle(document.body).color;
        ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        for (let i = 0; i <= 8; i++) {
          const x = xMin + (xMax - xMin) * (i / 8);
          const px = xToPx(x);
          const label = (i === 0) ? '0' : (i === 8 ? '2π' : `${(i/4)}π`);
          ctx.fillText(label, px, H - pad + 6);
        }
      }

      return {
        drawCurves(f, coeffs, N) {
          const xs = linspace(xMin, xMax, 1400);
          const yTrue = new Float64Array(xs.length);
          const yApprox = new Float64Array(xs.length);

          let ymin = Infinity, ymax = -Infinity;
          for (let i = 0; i < xs.length; i++) {
            const x = xs[i];
            const yt = f(x);
            const ya = fourierAt(x, coeffs, N);
            yTrue[i] = yt; yApprox[i] = ya;
            if (Number.isFinite(yt)) { ymin = Math.min(ymin, yt); ymax = Math.max(ymax, yt); }
            if (Number.isFinite(ya)) { ymin = Math.min(ymin, ya); ymax = Math.max(ymax, ya); }
          }
          if (!Number.isFinite(ymin) || !Number.isFinite(ymax)) { ymin = -1; ymax = 1; }
          const margin = 0.1 * (ymax - ymin || 2);
          yMin = ymin - margin; yMax = ymax + margin;

          drawAxes();

          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent2');
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < xs.length; i++) {
            const px = xToPx(xs[i]), py = yToPx(yTrue[i]);
            if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
          }
          ctx.stroke();

          ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          for (let i = 0; i < xs.length; i++) {
            const px = xToPx(xs[i]), py = yToPx(yApprox[i]);
            if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
          }
          ctx.stroke();
        }
      };
    }

    // ---------- App ----------
    const canvas = document.getElementById('plot');
    const funcInput = document.getElementById('funcInput');
    const nRange = document.getElementById('nRange');
    const nLabel = document.getElementById('nLabel');
    const statusEl = document.getElementById('status');
    const recomputeBtn = document.getElementById('recomputeBtn');

    let plot = null;
    let coeffs = null;

    // Built-in template functions (no dynamic eval needed)
    const templates = {
      square: {
        expr: 'x < PI ? 1 : -1',
        fn: (x) => (wrap2pi(x) < Math.PI ? 1 : -1)
      },
      saw: {
        expr: 'x/PI - 1',
        fn: (x) => (wrap2pi(x) / Math.PI - 1)
      },
      tri: {
        expr: '(2/PI)*asin(sin(x))',
        fn: (x) => (2/Math.PI) * Math.asin(Math.sin(wrap2pi(x)))
      },
      sine: {
        expr: 'sin(x)',
        fn: (x) => Math.sin(wrap2pi(x))
      },
      abssin: {
        expr: 'abs(sin(x))',
        fn: (x) => Math.abs(Math.sin(wrap2pi(x)))
      },
      cosmix: {
        expr: 'cos(x) + 0.3*cos(3*x)',
        fn: (x) => Math.cos(wrap2pi(x)) + 0.3*Math.cos(3*wrap2pi(x))
      }
    };

    let f = templates.square.fn; // default

    function setStatus(text, kind = 'info') {
      statusEl.textContent = text || '';
      statusEl.style.color = kind === 'error' ? getComputedStyle(document.documentElement).getPropertyValue('--error') : getComputedStyle(document.documentElement).getPropertyValue('--muted');
    }

    function recomputeCoeffs() {
      const Nmax = parseInt(nRange.max, 10);
      setStatus('Computing coefficients…');
      coeffs = computeCoeffs(f, Nmax);
      setStatus(`Coefficients ready up to N = ${Nmax}.`);
    }

    function render() {
      const N = parseInt(nRange.value, 10);
      nLabel.textContent = `N = ${N}`;
      if (!plot) plot = makePlot(canvas);
      if (!coeffs) recomputeCoeffs();
      plot.drawCurves(f, coeffs, N);
    }

    function applyExpr(expr) {
      try {
        const newF = makeUserFunction(expr);
        // quick sanity
        void newF(0); void newF(1);
        f = newF;
        recomputeCoeffs();
        render();
        setStatus('');
      } catch (e) {
        console.error(e);
        setStatus(`Invalid function expression: ${e.message}. Use math functions like sin(x), cos(x), abs(x), sqrt(x), and operators +, -, *, /, ^. Example: sin(x) + 0.5*cos(3*x)`, 'error');
      }
    }

    function applyTemplate(key) {
      const t = templates[key];
      if (!t) return;
      funcInput.value = t.expr;
      f = t.fn; // avoid dynamic eval
      recomputeCoeffs();
      render();
      setStatus('');
    }

    // Events
    nRange.addEventListener('input', () => { render(); });
    recomputeBtn.addEventListener('click', () => { recomputeCoeffs(); render(); });
    document.querySelectorAll('.templates .btn').forEach(btn => {
      btn.addEventListener('click', () => applyTemplate(btn.dataset.template));
    });
    funcInput.addEventListener('change', () => applyExpr(funcInput.value));
    window.addEventListener('resize', () => { plot = null; render(); });

    // Initial
    applyTemplate('square');
  </script>
</body>
</html>
